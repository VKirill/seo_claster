"""
Async Batch SERP Client
–ú–∞—Å—Å–æ–≤–∞—è –æ—Ç–ø—Ä–∞–≤–∫–∞ –∑–∞–ø—Ä–æ—Å–æ–≤ –≤ –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ–º —Ä–µ–∂–∏–º–µ xmlstock

Workflow:
1. –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –í–°–ï –∑–∞–ø—Ä–æ—Å—ã —Å delayed=1 ‚Üí –ø–æ–ª—É—á–∞–µ–º –≤—Å–µ req_id
2. –ñ–¥—ë–º 10-20 —Å–µ–∫—É–Ω–¥
3. –ü–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ –∑–∞–ø—Ä–∞—à–∏–≤–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –ø–æ –≤—Å–µ–º req_id
4. –ü–æ–≤—Ç–æ—Ä—è–µ–º –¥–ª—è —Ç–µ—Ö —á—Ç–æ –µ—â—ë –Ω–µ –≥–æ—Ç–æ–≤—ã (–∫–æ–¥ 202)
"""

import asyncio
import aiohttp
from typing import List, Dict, Any, Optional, Callable
from dataclasses import dataclass
import re
from datetime import datetime
import time


@dataclass
class PendingRequest:
    """–û—Ç–ª–æ–∂–µ–Ω–Ω—ã–π –∑–∞–ø—Ä–æ—Å"""
    query: str
    req_id: str
    sent_at: datetime
    attempts: int = 0
    last_error: Optional[str] = None


class AsyncBatchSERPClient:
    """
    –ú–∞—Å—Å–æ–≤–∞—è –æ—Ç–ø—Ä–∞–≤–∫–∞ –∏ –ø–æ–ª—É—á–µ–Ω–∏–µ SERP –¥–∞–Ω–Ω—ã—Ö –≤ –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ–º —Ä–µ–∂–∏–º–µ
    
    –ü—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞:
    - –û—Ç–ø—Ä–∞–≤–∫–∞ 1000+ –∑–∞–ø—Ä–æ—Å–æ–≤ –∑–∞ –Ω–µ—Å–∫–æ–ª—å–∫–æ —Å–µ–∫—É–Ω–¥
    - –ü–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ–µ –ø–æ–ª—É—á–µ–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤
    - –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–µ –ø–æ–≤—Ç–æ—Ä—ã –¥–ª—è –Ω–µ–∑–∞–≤–µ—Ä—à—ë–Ω–Ω—ã—Ö (202)
    - –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ req_id –≤ Master DB –¥–ª—è –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è
    """
    
    # –ì–ª–æ–±–∞–ª—å–Ω—ã–π —Ñ–ª–∞–≥ –ø–µ—Ä–µ–≥—Ä—É–∑–∫–∏ —Å–µ—Ä–≤–µ—Ä–∞ (503)
    # –ï—Å–ª–∏ —Å–µ—Ä–≤–µ—Ä –≤–µ—Ä–Ω—É–ª 503, –≤—Å–µ –∑–∞–ø—Ä–æ—Å—ã –∂–¥—É—Ç 60 —Å–µ–∫ –ø–µ—Ä–µ–¥ —Å–ª–µ–¥—É—é—â–µ–π –ø–æ–ø—ã—Ç–∫–æ–π
    _last_503_time: Optional[float] = None
    _503_lock: Optional[asyncio.Lock] = None
    
    @classmethod
    def _get_503_lock(cls) -> asyncio.Lock:
        """–ü–æ–ª—É—á–∏—Ç—å –∏–ª–∏ —Å–æ–∑–¥–∞—Ç—å Lock –¥–ª—è —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏"""
        if cls._503_lock is None:
            cls._503_lock = asyncio.Lock()
        return cls._503_lock
    
    def __init__(
        self,
        api_key: str,
        lr: int = 213,
        max_concurrent_send: int = 10,  # –£–º–µ–Ω—å—à–∏–ª–∏ –¥–æ 10 –¥–ª—è —Å—Ç–∞–±–∏–ª—å–Ω–æ—Å—Ç–∏ (–±—ã–ª–æ 50)
        max_concurrent_fetch: int = 20,  # –ü–æ–ª—É—á–µ–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ (–±—ã–ª–æ 50)
        initial_delay: int = 10,  # –ü–µ—Ä–≤–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞ –ø–µ—Ä–µ–¥ –ø—Ä–æ–≤–µ—Ä–∫–æ–π
        retry_delay: int = 5,  # –ó–∞–¥–µ—Ä–∂–∫–∞ –º–µ–∂–¥—É –ø–æ–≤—Ç–æ—Ä–∞–º–∏
        max_attempts: int = 100,  # –ú–∞–∫—Å–∏–º—É–º –ø–æ–ø—ã—Ç–æ–∫ –ø–æ–ª—É—á–µ–Ω–∏—è (–ø—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏ –±–µ–∑ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è)
        requests_per_second: float = 50.0  # Rate limit: —Å–Ω–∏–∂–µ–Ω –¥–æ 50 –∑–∞–ø—Ä–æ—Å–æ–≤/—Å–µ–∫ –¥–ª—è —Å—Ç–∞–±–∏–ª—å–Ω–æ—Å—Ç–∏
    ):
        """
        Args:
            api_key: API –∫–ª—é—á xmlstock (user:key)
            lr: –†–µ–≥–∏–æ–Ω
            max_concurrent_send: –ú–∞–∫—Å –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω—ã—Ö –æ—Ç–ø—Ä–∞–≤–æ–∫ (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é 10 –¥–ª—è —Å—Ç–∞–±–∏–ª—å–Ω–æ—Å—Ç–∏)
            max_concurrent_fetch: –ú–∞–∫—Å –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω—ã—Ö –ø–æ–ª—É—á–µ–Ω–∏–π (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é 20)
            initial_delay: –ó–∞–¥–µ—Ä–∂–∫–∞ –ø–µ—Ä–µ–¥ –ø–µ—Ä–≤–æ–π –ø—Ä–æ–≤–µ—Ä–∫–æ–π (—Å–µ–∫)
            retry_delay: –ó–∞–¥–µ—Ä–∂–∫–∞ –º–µ–∂–¥—É –ø–æ–≤—Ç–æ—Ä–∞–º–∏ (—Å–µ–∫)
            max_attempts: –ú–∞–∫—Å –ø–æ–ø—ã—Ç–æ–∫ –ø–æ–ª—É—á–µ–Ω–∏—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ (100 = –ø–æ—á—Ç–∏ –±–µ–∑ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è)
            requests_per_second: –ú–∞–∫—Å–∏–º—É–º –∑–∞–ø—Ä–æ—Å–æ–≤ –≤ —Å–µ–∫—É–Ω–¥—É (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é 50 –¥–ª—è —Å—Ç–∞–±–∏–ª—å–Ω–æ—Å—Ç–∏)
        """
        self.api_key = api_key
        self.lr = lr
        self.max_concurrent_send = max_concurrent_send
        self.max_concurrent_fetch = max_concurrent_fetch
        self.initial_delay = initial_delay
        self.retry_delay = retry_delay
        self.max_attempts = max_attempts
        self.requests_per_second = requests_per_second
        
        # Rate limiting: –º–∏–Ω–∏–º–∞–ª—å–Ω–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞ –º–µ–∂–¥—É –∑–∞–ø—Ä–æ—Å–∞–º–∏
        self.min_request_interval = 1.0 / requests_per_second if requests_per_second > 0 else 0.01
        self._last_request_time = 0.0
        self._rate_limit_lock = asyncio.Lock()
        
        # –ü–∞—Ä—Å–∏–Ω–≥ –∫–ª—é—á–∞
        if ':' in api_key:
            self.user, self.key = api_key.split(':', 1)
        else:
            self.user = api_key
            self.key = api_key
        
        self.url = "https://xmlstock.com/yandex/xml/"
        self._session: Optional[aiohttp.ClientSession] = None
        self._session_lock = asyncio.Lock()  # –ë–ª–æ–∫–∏—Ä–æ–≤–∫–∞ –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è/–∑–∞–∫—Ä—ã—Ç–∏—è —Å–µ—Å—Å–∏–∏
    
    @classmethod
    async def _check_and_wait_for_503(cls):
        """–ü—Ä–æ–≤–µ—Ä–∏—Ç—å, –±—ã–ª –ª–∏ –Ω–µ–¥–∞–≤–Ω–æ 503, –∏ –µ—Å–ª–∏ –¥–∞ - –ø–æ–¥–æ–∂–¥–∞—Ç—å"""
        async with cls._get_503_lock():
            if cls._last_503_time is not None:
                time_since_503 = time.time() - cls._last_503_time
                if time_since_503 < 60:
                    wait_time = 60 - time_since_503
                    print(f"   ‚ö†Ô∏è  –°–µ—Ä–≤–µ—Ä –±—ã–ª –ø–µ—Ä–µ–≥—Ä—É–∂–µ–Ω (503) {time_since_503:.1f} —Å–µ–∫ –Ω–∞–∑–∞–¥. –û–∂–∏–¥–∞–Ω–∏–µ {wait_time:.1f} —Å–µ–∫...")
                    await asyncio.sleep(wait_time)
                    cls._last_503_time = None  # –°–±—Ä–∞—Å—ã–≤–∞–µ–º –ø–æ—Å–ª–µ –æ–∂–∏–¥–∞–Ω–∏—è
    
    @classmethod
    async def _mark_503_error(cls):
        """–û—Ç–º–µ—Ç–∏—Ç—å —á—Ç–æ —Å–µ—Ä–≤–µ—Ä –≤–µ—Ä–Ω—É–ª 503"""
        async with cls._get_503_lock():
            cls._last_503_time = time.time()
    
    async def _wait_for_rate_limit(self):
        """–û–∂–∏–¥–∞–Ω–∏–µ –¥–ª—è —Å–æ–±–ª—é–¥–µ–Ω–∏—è rate limit (–Ω–µ –±–æ–ª–µ–µ requests_per_second –∑–∞–ø—Ä–æ—Å–æ–≤/—Å–µ–∫)"""
        async with self._rate_limit_lock:
            current_time = time.time()
            time_since_last = current_time - self._last_request_time
            
            if time_since_last < self.min_request_interval:
                wait_time = self.min_request_interval - time_since_last
                await asyncio.sleep(wait_time)
            
            self._last_request_time = time.time()
    
    async def _ensure_session(self):
        """–°–æ–∑–¥–∞—Ç—å —Å–µ—Å—Å–∏—é –µ—Å–ª–∏ –Ω–µ—Ç (thread-safe)"""
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –±–µ–∑ –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏ –¥–ª—è –±—ã—Å—Ç—Ä–æ–≥–æ –ø—É—Ç–∏
        if self._session is not None and not self._session.closed:
            return
        
        # –ò—Å–ø–æ–ª—å–∑—É–µ–º –±–ª–æ–∫–∏—Ä–æ–≤–∫—É –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è/–∑–∞–∫—Ä—ã—Ç–∏—è —Å–µ—Å—Å–∏–∏
        async with self._session_lock:
            # –î–≤–æ–π–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ—Å–ª–µ –ø–æ–ª—É—á–µ–Ω–∏—è –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏
            if self._session is not None and not self._session.closed:
                return
            
            # –ó–∞–∫—Ä—ã–≤–∞–µ–º —Å—Ç–∞—Ä—É—é —Å–µ—Å—Å–∏—é –µ—Å–ª–∏ –µ—Å—Ç—å (–Ω–∞ –≤—Å—è–∫–∏–π —Å–ª—É—á–∞–π)
            if self._session is not None:
                try:
                    if not self._session.closed:
                        await self._session.close()
                    # –ó–∞–∫—Ä—ã–≤–∞–µ–º connector –µ—Å–ª–∏ –µ—Å—Ç—å
                    if hasattr(self._session, '_connector') and self._session._connector:
                        await self._session._connector.close()
                    # –î–∞—ë–º –≤—Ä–µ–º—è –∑–∞–∫—Ä—ã—Ç—å—Å—è
                    await asyncio.sleep(0.25)
                except Exception:
                    # –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º –æ—à–∏–±–∫–∏ –ø—Ä–∏ –∑–∞–∫—Ä—ã—Ç–∏–∏
                    pass
                finally:
                    self._session = None
            
            # –°–æ–∑–¥–∞—ë–º –Ω–æ–≤—É—é —Å–µ—Å—Å–∏—é —Å –ø—Ä–∞–≤–∏–ª—å–Ω—ã–º–∏ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞–º–∏
            # force_close=False –¥–ª—è –ø–µ—Ä–µ–∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π (–±—ã—Å—Ç—Ä–µ–µ)
            # ttl_dns_cache=300 –¥–ª—è –∫—ç—à–∏—Ä–æ–≤–∞–Ω–∏—è DNS –Ω–∞ 5 –º–∏–Ω—É—Ç
            # enable_cleanup_closed=True –¥–ª—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–π –æ—á–∏—Å—Ç–∫–∏ –∑–∞–∫—Ä—ã—Ç—ã—Ö —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π
            connector = aiohttp.TCPConnector(
                limit=100, 
                limit_per_host=50, 
                force_close=False,
                ttl_dns_cache=300,
                enable_cleanup_closed=True
            )
            timeout = aiohttp.ClientTimeout(total=30, connect=10)
            self._session = aiohttp.ClientSession(
                connector=connector, 
                timeout=timeout,
                raise_for_status=False  # –ù–µ –∫–∏–¥–∞–µ–º –∏—Å–∫–ª—é—á–µ–Ω–∏—è –Ω–∞ HTTP –æ—à–∏–±–∫–∏
            )
    
    async def close(self):
        """–ó–∞–∫—Ä—ã—Ç—å —Å–µ—Å—Å–∏—é –∏ connector (thread-safe)"""
        async with self._session_lock:
            if self._session:
                try:
                    # –°–Ω–∞—á–∞–ª–∞ –∑–∞–∫—Ä—ã–≤–∞–µ–º connector (–æ—Å–≤–æ–±–æ–∂–¥–∞–µ—Ç —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è)
                    if hasattr(self._session, '_connector') and self._session._connector:
                        if not self._session._connector.closed:
                            await self._session._connector.close()
                    
                    # –ó–∞—Ç–µ–º –∑–∞–∫—Ä—ã–≤–∞–µ–º —Å–∞–º—É —Å–µ—Å—Å–∏—é
                    if not self._session.closed:
                        await self._session.close()
                    
                    # –î–∞—ë–º –±–æ–ª—å—à–µ –≤—Ä–µ–º–µ–Ω–∏ –¥–ª—è –ø–æ–ª–Ω–æ–≥–æ –∑–∞–∫—Ä—ã—Ç–∏—è –≤—Å–µ—Ö —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π
                    await asyncio.sleep(0.5)
                except Exception as e:
                    # –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º –æ—à–∏–±–∫–∏ –ø—Ä–∏ –∑–∞–∫—Ä—ã—Ç–∏–∏, –Ω–æ –ª–æ–≥–∏—Ä—É–µ–º –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏
                    pass
                finally:
                    self._session = None
    
    async def process_queries_batch(
        self,
        queries: List[str],
        progress_callback: Optional[Callable] = None,
        on_req_id_received: Optional[Callable] = None,
        batch_size: int = 50,  # –ë–µ–∑–æ–ø–∞—Å–Ω—ã–π —Ä–∞–∑–º–µ—Ä –±–∞—Ç—á–∞: –æ—Ç–ø—Ä–∞–≤–∏–ª 50 ‚Üí –ø–æ–ª—É—á–∏–ª ‚Üí —Å–ª–µ–¥—É—é—â–∏–µ 50
        completion_threshold: float = 0.95  # –ñ–¥—ë–º 95% –ø–µ—Ä–µ–¥ —Å–ª–µ–¥—É—é—â–∏–º –±–∞—Ç—á–µ–º
    ) -> Dict[str, Any]:
        """
        –ú–∞—Å—Å–æ–≤–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –∑–∞–ø—Ä–æ—Å–æ–≤ –≤ –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ–º —Ä–µ–∂–∏–º–µ —Å –±–∞—Ç—á–µ–≤–æ–π –æ—Ç–ø—Ä–∞–≤–∫–æ–π
        
        –°—Ç—Ä–∞—Ç–µ–≥–∏—è: –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –±–∞—Ç—á ‚Üí –∂–¥—ë–º –ø–æ–ª—É—á–µ–Ω–∏—è ‚Üí –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–ª–µ–¥—É—é—â–∏–π –±–∞—Ç—á
        –≠—Ç–æ –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–∞–µ—Ç –ø–µ—Ä–µ–≥—Ä—É–∑–∫—É —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π –∏ –æ–±–µ—Å–ø–µ—á–∏–≤–∞–µ—Ç —Å—Ç–∞–±–∏–ª—å–Ω–æ—Å—Ç—å.
        
        Args:
            queries: –°–ø–∏—Å–æ–∫ –∑–∞–ø—Ä–æ—Å–æ–≤
            progress_callback: Callback(current, total, query, status)
            on_req_id_received: Callback(query, req_id) –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ req_id
            batch_size: –†–∞–∑–º–µ—Ä –±–∞—Ç—á–∞ (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é 50 - –±–µ–∑–æ–ø–∞—Å–Ω—ã–π —Ä–∞–∑–º–µ—Ä)
            completion_threshold: –ü–æ—Ä–æ–≥ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –ø–µ—Ä–µ–¥ —Å–ª–µ–¥—É—é—â–∏–º –±–∞—Ç—á–µ–º (0.95 = 95%)
            
        Returns:
            Dict —Å —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞–º–∏ –∏ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–æ–π
        """
        # –°–æ–∑–¥–∞—ë–º —Å–µ—Å—Å–∏—é –æ–¥–∏–Ω —Ä–∞–∑ –≤ –Ω–∞—á–∞–ª–µ –æ–±—Ä–∞–±–æ—Ç–∫–∏
        await self._ensure_session()
        
        total = len(queries)
        print(f"\nüöÄ –ú–∞—Å—Å–æ–≤–∞—è –æ—Ç–ø—Ä–∞–≤–∫–∞ {total} –∑–∞–ø—Ä–æ—Å–æ–≤ –≤ async —Ä–µ–∂–∏–º–µ xmlstock")
        print(f"   üì¶ –°—Ç—Ä–∞—Ç–µ–≥–∏—è: –û–¢–ü–†–ê–í–ò–õ {batch_size} ‚Üí –ü–û–õ–£–ß–ò–õ ‚Üí –°–õ–ï–î–£–Æ–©–ò–ï {batch_size}")
        print(f"   –ü–æ—Ä–æ–≥ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –±–∞—Ç—á–∞: {completion_threshold*100:.0f}% –ø–µ—Ä–µ–¥ —Å–ª–µ–¥—É—é—â–∏–º")
        print(f"   üîÑ –ü–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ—Å—Ç—å –æ—Ç–ø—Ä–∞–≤–∫–∏: {self.max_concurrent_send} (–∫–æ–Ω—Å–µ—Ä–≤–∞—Ç–∏–≤–Ω–æ –¥–ª—è —Å—Ç–∞–±–∏–ª—å–Ω–æ—Å—Ç–∏)")
        print(f"   üì• –ü–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ—Å—Ç—å –ø–æ–ª—É—á–µ–Ω–∏—è: {self.max_concurrent_fetch}")
        print(f"   ‚ö° Rate limit: {self.requests_per_second:.0f} –∑–∞–ø—Ä–æ—Å–æ–≤/—Å–µ–∫")
        print(f"   ‚è≥ –ü–æ–ø—ã—Ç–æ–∫ –ø–æ–ª—É—á–µ–Ω–∏—è –Ω–∞ –±–∞—Ç—á: {self.max_attempts} (–∂–¥—ë–º –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è)")
        print()
        
        # –†–∞–∑–±–∏–≤–∞–µ–º –Ω–∞ –±–∞—Ç—á–∏
        batches = []
        for i in range(0, total, batch_size):
            batch = queries[i:i + batch_size]
            batches.append(batch)
        
        print(f"üì¶ –í—Å–µ–≥–æ –±–∞—Ç—á–µ–π: {len(batches)}")
        print()
        
        all_results = []
        all_failed_send = []
        all_failed_fetch = []
        total_sent = 0
        
        # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –∫–∞–∂–¥—ã–π –±–∞—Ç—á
        for batch_num, batch_queries in enumerate(batches, 1):
            batch_total = len(batch_queries)
            print(f"{'='*80}")
            print(f"üì¶ –ë–ê–¢–ß {batch_num}/{len(batches)}: {batch_total} –∑–∞–ø—Ä–æ—Å–æ–≤")
            print(f"{'='*80}")
            
            # –ü–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–∏ –ø–µ—Ä–µ—Å–æ–∑–¥–∞—ë–º —Å–µ—Å—Å–∏—é –¥–ª—è –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–µ–Ω–∏—è –ø—Ä–æ–±–ª–µ–º —Å —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è–º–∏
            # –ö–∞–∂–¥—ã–µ 20 –±–∞—Ç—á–µ–π (20 * 50 = 1000 –∑–∞–ø—Ä–æ—Å–æ–≤)
            if batch_num > 1 and batch_num % 20 == 1:
                print(f"üîÑ –ü–µ—Ä–µ—Å–æ–∑–¥–∞–Ω–∏–µ —Å–µ—Å—Å–∏–∏ –¥–ª—è —Å–≤–µ–∂–µ—Å—Ç–∏ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π (–∫–∞–∂–¥—ã–µ 1000 –∑–∞–ø—Ä–æ—Å–æ–≤)...")
                await self.close()
                await asyncio.sleep(1.0)  # –î–∞—ë–º –≤—Ä–µ–º—è –ø–æ–ª–Ω–æ—Å—Ç—å—é –∑–∞–∫—Ä—ã—Ç—å—Å—è
                await self._ensure_session()
                print(f"‚úì –°–µ—Å—Å–∏—è –ø–µ—Ä–µ—Å–æ–∑–¥–∞–Ω–∞")
                print()
            
            # ========================================
            # –≠–¢–ê–ü 1: –û—Ç–ø—Ä–∞–≤–∫–∞ –±–∞—Ç—á–∞ (–ø–æ–ª—É—á–µ–Ω–∏–µ req_id)
            # ========================================
            print(f"üì§ –û—Ç–ø—Ä–∞–≤–∫–∞ –∑–∞–ø—Ä–æ—Å–æ–≤ —Å delayed=1...")
            
            send_semaphore = asyncio.Semaphore(self.max_concurrent_send)
            send_tasks = []
            
            for i, query in enumerate(batch_queries, 1):
                global_index = (batch_num - 1) * batch_size + i
                task = self._send_delayed_request(
                    query, 
                    global_index, 
                    total, 
                    send_semaphore,
                    progress_callback,
                    on_req_id_received
                )
                send_tasks.append(task)
            
            # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –≤—Å–µ –∑–∞–ø—Ä–æ—Å—ã –±–∞—Ç—á–∞ –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ
            pending_requests = await asyncio.gather(*send_tasks, return_exceptions=True)
            
            # –§–∏–ª—å—Ç—Ä—É–µ–º —É—Å–ø–µ—à–Ω—ã–µ
            valid_pending = []
            failed_queries = []
            
            for i, result in enumerate(pending_requests):
                if isinstance(result, Exception):
                    query = batch_queries[i] if i < len(batch_queries) else "Unknown"
                    error_msg = str(result)
                    failed_queries.append({
                        'query': query,
                        'error': error_msg
                    })
                elif isinstance(result, PendingRequest):
                    valid_pending.append(result)
                else:
                    query = batch_queries[i] if i < len(batch_queries) else "Unknown"
                    failed_queries.append({
                        'query': query,
                        'error': "Unknown error"
                    })
            
            total_sent += len(valid_pending)
            all_failed_send.extend(failed_queries)
            
            print(f"‚úì –û—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ: {len(valid_pending)}/{batch_total}")
            if failed_queries:
                print(f"‚ö†Ô∏è  –û—à–∏–±–æ–∫ –æ—Ç–ø—Ä–∞–≤–∫–∏ –≤ –±–∞—Ç—á–µ: {len(failed_queries)}")
                # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –ø–µ—Ä–≤—ã–µ 3 –æ—à–∏–±–∫–∏ –¥–ª—è –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∏
                for i, failed in enumerate(failed_queries[:3], 1):
                    query_preview = failed['query'][:50] + "..." if len(failed['query']) > 50 else failed['query']
                    error_preview = failed['error'][:100] + "..." if len(failed['error']) > 100 else failed['error']
                    print(f"   {i}. '{query_preview}': {error_preview}")
                if len(failed_queries) > 3:
                    print(f"   ... –∏ –µ—â—ë {len(failed_queries) - 3} –æ—à–∏–±–æ–∫")
            print()
            
            if not valid_pending:
                print(f"‚ö†Ô∏è  –ë–∞—Ç—á {batch_num}: –Ω–µ—Ç —É—Å–ø–µ—à–Ω—ã—Ö –æ—Ç–ø—Ä–∞–≤–æ–∫, –ø–µ—Ä–µ—Ö–æ–¥–∏–º –∫ —Å–ª–µ–¥—É—é—â–µ–º—É")
                print(f"   üí° –í—Å–µ –∑–∞–ø—Ä–æ—Å—ã –≤ –±–∞—Ç—á–µ –∑–∞–≤–µ—Ä—à–∏–ª–∏—Å—å –æ—à–∏–±–∫–æ–π. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ:")
                print(f"      ‚Ä¢ –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ –∏–Ω—Ç–µ—Ä–Ω–µ—Ç—É")
                print(f"      ‚Ä¢ –î–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å API xmlstock")
                print(f"      ‚Ä¢ –ü—Ä–∞–≤–∏–ª—å–Ω–æ—Å—Ç—å API –∫–ª—é—á–∞")
                print()
                
                # –ï—Å–ª–∏ —Å–ª–∏—à–∫–æ–º –º–Ω–æ–≥–æ –æ—à–∏–±–æ–∫ –ø–æ–¥—Ä—è–¥ - –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–∞–µ–º
                if batch_num >= 3 and len(all_failed_send) == batch_num * batch_size:
                    print(f"‚ö†Ô∏è  –í–ù–ò–ú–ê–ù–ò–ï: {batch_num} –±–∞—Ç—á–µ–π –ø–æ–¥—Ä—è–¥ –∑–∞–≤–µ—Ä—à–∏–ª–∏—Å—å –æ—à–∏–±–∫–∞–º–∏!")
                    print(f"   –í–æ–∑–º–æ–∂–Ω–æ –ø—Ä–æ–±–ª–µ–º–∞ —Å –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ–º –∫ xmlstock API.")
                    print(f"   –†–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è –ø—Ä–æ–≤–µ—Ä–∏—Ç—å –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∏ –ø–æ–≤—Ç–æ—Ä–∏—Ç—å –ø–æ–ø—ã—Ç–∫—É –ø–æ–∑–∂–µ.\n")
                
                continue
            
            # ========================================
            # –≠–¢–ê–ü 2: –û–∂–∏–¥–∞–Ω–∏–µ –ø–µ—Ä–µ–¥ –ø–µ—Ä–≤–æ–π –ø—Ä–æ–≤–µ—Ä–∫–æ–π
            # ========================================
            print(f"‚è≥ –û–∂–∏–¥–∞–Ω–∏–µ {self.initial_delay} —Å–µ–∫ –ø–µ—Ä–µ–¥ –ø–µ—Ä–≤–æ–π –ø—Ä–æ–≤–µ—Ä–∫–æ–π...")
            await asyncio.sleep(self.initial_delay)
            print()
            
            # ========================================
            # –≠–¢–ê–ü 3: –ü–æ–ª—É—á–µ–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –±–∞—Ç—á–∞
            # ========================================
            print(f"üì• –ü–æ–ª—É—á–µ–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –±–∞—Ç—á–∞...")
            
            fetch_semaphore = asyncio.Semaphore(self.max_concurrent_fetch)
            batch_results = []
            batch_failed_fetch = []
            
            # –ü–æ–≤—Ç–æ—Ä—è–µ–º –¥–æ max_attempts –ø–æ–ø—ã—Ç–æ–∫ –∏–ª–∏ –ø–æ–∫–∞ –Ω–µ –ø–æ–ª—É—á–∏–º –Ω—É–∂–Ω—ã–π –ø—Ä–æ—Ü–µ–Ω—Ç
            remaining = valid_pending[:]
            target_completed = int(len(valid_pending) * completion_threshold)
            
            for attempt in range(self.max_attempts):
                if not remaining:
                    break
                
                # –î–ª—è –º–∞–ª–µ–Ω—å–∫–∏—Ö –±–∞—Ç—á–µ–π (‚â§50): –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø–æ–ª—É—á–∏—Ç—å –≤—Å–µ –∏–ª–∏ –ø–æ—á—Ç–∏ –≤—Å–µ
                # –î–ª—è –±–æ–ª—å—à–∏—Ö –±–∞—Ç—á–µ–π: –∏—Å–ø–æ–ª—å–∑—É–µ–º –ø–æ—Ä–æ–≥ completion_threshold
                if len(valid_pending) <= 50:
                    # –ú–∞–ª–µ–Ω—å–∫–∏–π –±–∞—Ç—á: –∂–¥—ë–º –≤—Å–µ –∏–ª–∏ –ø–µ—Ä–µ—Ö–æ–¥–∏–º –ø–æ—Å–ª–µ 10 –ø–æ–ø—ã—Ç–æ–∫
                    if not remaining or attempt >= 10:
                        if remaining:
                            print(f"\n‚è≠Ô∏è  –ü–µ—Ä–µ—Ö–æ–¥ –ø–æ—Å–ª–µ {attempt + 1} –ø–æ–ø—ã—Ç–æ–∫: {len(batch_results)}/{len(valid_pending)} –ø–æ–ª—É—á–µ–Ω–æ")
                        break
                else:
                    # –ë–æ–ª—å—à–æ–π –±–∞—Ç—á: –∏—Å–ø–æ–ª—å–∑—É–µ–º –ø–æ—Ä–æ–≥
                    if len(batch_results) >= target_completed:
                        print(f"\n‚úì –î–æ—Å—Ç–∏–≥–Ω—É—Ç –ø–æ—Ä–æ–≥ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è: {len(batch_results)}/{len(valid_pending)} ({len(batch_results)/len(valid_pending)*100:.1f}%)")
                        print(f"   –ü–µ—Ä–µ—Ö–æ–¥–∏–º –∫ —Å–ª–µ–¥—É—é—â–µ–º—É –±–∞—Ç—á—É...")
                        break
                
                if self.max_attempts >= 50:
                    print(f"\n   –ü–æ–ø—ã—Ç–∫–∞ {attempt + 1}: –ø—Ä–æ–≤–µ—Ä–∫–∞ {len(remaining)} –∑–∞–ø—Ä–æ—Å–æ–≤...")
                else:
                    print(f"\n   –ü–æ–ø—ã—Ç–∫–∞ {attempt + 1}/{self.max_attempts}: –ø—Ä–æ–≤–µ—Ä–∫–∞ {len(remaining)} –∑–∞–ø—Ä–æ—Å–æ–≤...")
                
                # –ü–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ –∑–∞–ø—Ä–∞—à–∏–≤–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã
                fetch_tasks = []
                for pending in remaining:
                    task = self._fetch_result_by_req_id(
                        pending,
                        fetch_semaphore,
                        progress_callback
                    )
                    fetch_tasks.append(task)
                
                fetch_results = await asyncio.gather(*fetch_tasks, return_exceptions=True)
                
                # –†–∞–∑–±–∏—Ä–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã
                still_pending = []
                
                for i, result in enumerate(fetch_results):
                    if isinstance(result, Exception):
                        pending = remaining[i]
                        pending.attempts += 1
                        pending.last_error = str(result)
                        still_pending.append(pending)
                    
                    elif isinstance(result, dict):
                        if result.get('status') == 'pending':
                            pending = remaining[i]
                            pending.attempts += 1
                            still_pending.append(pending)
                        
                        elif result.get('status') == 'retry_503':
                            pending = remaining[i]
                            pending.attempts += 1
                            pending.last_error = result.get('error', '503 Service Temporarily Unavailable')
                            still_pending.append(pending)
                        
                        elif result.get('status') == 'completed':
                            batch_results.append(result)
                        
                        else:
                            batch_failed_fetch.append(result)
                
                print(f"   ‚úì –ü–æ–ª—É—á–µ–Ω–æ: {len(batch_results)}/{len(valid_pending)} ({len(batch_results)/len(valid_pending)*100:.1f}%)")
                print(f"   ‚è≥ –ï—â—ë –æ–∂–∏–¥–∞—é—Ç (202): {len(still_pending)}")
                if batch_failed_fetch:
                    print(f"   ‚ùå –û—à–∏–±–æ–∫: {len(batch_failed_fetch)}")
                
                # –û–±–Ω–æ–≤–ª—è–µ–º —Å–ø–∏—Å–æ–∫ –æ–∂–∏–¥–∞—é—â–∏—Ö
                remaining = still_pending
                
                # –ï—Å–ª–∏ –µ—â—ë –µ—Å—Ç—å –æ–∂–∏–¥–∞—é—â–∏–µ –∏ –Ω–µ –ø–æ—Å–ª–µ–¥–Ω—è—è –ø–æ–ø—ã—Ç–∫–∞ - –∂–¥—ë–º
                if remaining and attempt < self.max_attempts - 1:
                    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –≥–ª–æ–±–∞–ª—å–Ω—ã–π —Ñ–ª–∞–≥ 503
                    async with self._get_503_lock():
                        if self._last_503_time is not None:
                            time_since_503 = time.time() - self._last_503_time
                            if time_since_503 < 60:
                                delay = 60 - time_since_503
                                print(f"   ‚ö†Ô∏è  –°–µ—Ä–≤–µ—Ä –±—ã–ª –ø–µ—Ä–µ–≥—Ä—É–∂–µ–Ω (503). –û–∂–∏–¥–∞–Ω–∏–µ {delay:.1f} —Å–µ–∫...")
                                await asyncio.sleep(delay)
                                self._last_503_time = None
                            else:
                                delay = self.retry_delay
                                print(f"   –û–∂–∏–¥–∞–Ω–∏–µ {delay} —Å–µ–∫ –ø–µ—Ä–µ–¥ —Å–ª–µ–¥—É—é—â–µ–π –ø–æ–ø—ã—Ç–∫–æ–π...")
                                await asyncio.sleep(delay)
                        else:
                            delay = self.retry_delay
                            print(f"   –û–∂–∏–¥–∞–Ω–∏–µ {delay} —Å–µ–∫ –ø–µ—Ä–µ–¥ —Å–ª–µ–¥—É—é—â–µ–π –ø–æ–ø—ã—Ç–∫–æ–π...")
                            await asyncio.sleep(delay)
            
            # –û—Å—Ç–∞–≤—à–∏–µ—Å—è –ø–æ—Å–ª–µ –≤—Å–µ—Ö –ø–æ–ø—ã—Ç–æ–∫ = failed
            for pending in remaining:
                batch_failed_fetch.append({
                    'query': pending.query,
                    'req_id': pending.req_id,
                    'status': 'failed',
                    'error': f"Not ready after {self.max_attempts} attempts: {pending.last_error}"
                })
            
            all_results.extend(batch_results)
            all_failed_fetch.extend(batch_failed_fetch)
            
            print(f"\n‚úì –ë–∞—Ç—á {batch_num} –∑–∞–≤–µ—Ä—à—ë–Ω:")
            print(f"   –£—Å–ø–µ—à–Ω–æ: {len(batch_results)}/{batch_total}")
            print(f"   –û—à–∏–±–æ–∫ –æ—Ç–ø—Ä–∞–≤–∫–∏: {len(failed_queries)}")
            print(f"   –û—à–∏–±–æ–∫ –ø–æ–ª—É—á–µ–Ω–∏—è: {len(batch_failed_fetch)}")
            
            # –ï—Å–ª–∏ –Ω–µ –ø–æ—Å–ª–µ–¥–Ω–∏–π –±–∞—Ç—á - –Ω–µ–±–æ–ª—å—à–∞—è –ø–∞—É–∑–∞ –ø–µ—Ä–µ–¥ —Å–ª–µ–¥—É—é—â–∏–º
            if batch_num < len(batches):
                pause_time = 2  # –£–º–µ–Ω—å—à–∏–ª–∏ –ø–∞—É–∑—É —Ç.–∫. –±–∞—Ç—á–∏ –º–µ–Ω—å—à–µ (50 –≤–º–µ—Å—Ç–æ 200)
                # –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º –ø–∞—É–∑—É –µ—Å–ª–∏ –±—ã–ª–æ –º–Ω–æ–≥–æ –æ—à–∏–±–æ–∫
                if len(failed_queries) > batch_total * 0.5:
                    pause_time = 10
                    print(f"\n‚è∏Ô∏è  –£–≤–µ–ª–∏—á–µ–Ω–Ω–∞—è –ø–∞—É–∑–∞ {pause_time} —Å–µ–∫ (–º–Ω–æ–≥–æ –æ—à–∏–±–æ–∫ –≤ –±–∞—Ç—á–µ)...\n")
                else:
                    print(f"\n‚è∏Ô∏è  –ü–∞—É–∑–∞ {pause_time} —Å–µ–∫ –ø–µ—Ä–µ–¥ —Å–ª–µ–¥—É—é—â–∏–º –±–∞—Ç—á–µ–º...\n")
                await asyncio.sleep(pause_time)
        
        # –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –æ—à–∏–±–∫–∏ –æ—Ç–ø—Ä–∞–≤–∫–∏ –≤ —Ñ–æ—Ä–º–∞—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤
        failed_send_results = []
        for failed in all_failed_send:
            failed_send_results.append({
                'query': failed['query'],
                'req_id': None,
                'status': 'failed',
                'error': failed['error']
            })
        
        print(f"\n{'='*80}")
        print(f"‚úÖ –ú–∞—Å—Å–æ–≤–∞—è –∑–∞–≥—Ä—É–∑–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞")
        print(f"   –í—Å–µ–≥–æ: {total}")
        print(f"   –£—Å–ø–µ—à–Ω–æ: {len(all_results)}")
        print(f"   –û—à–∏–±–æ–∫ –æ—Ç–ø—Ä–∞–≤–∫–∏: {len(all_failed_send)}")
        print(f"   –û—à–∏–±–æ–∫ –ø–æ–ª—É—á–µ–Ω–∏—è: {len(all_failed_fetch)}")
        print(f"{'='*80}\n")
        
        return {
            'results': all_results + all_failed_fetch + failed_send_results,
            'stats': {
                'total': total,
                'sent': total_sent,
                'completed': len(all_results),
                'failed_send': len(all_failed_send),
                'failed_fetch': len([f for f in all_failed_fetch if f.get('status') == 'failed'])
            }
        }
    
    async def _send_delayed_request(
        self,
        query: str,
        index: int,
        total: int,
        semaphore: asyncio.Semaphore,
        progress_callback: Optional[Callable],
        on_req_id_received: Optional[Callable]
    ) -> PendingRequest:
        """–û—Ç–ø—Ä–∞–≤–∏—Ç—å –∑–∞–ø—Ä–æ—Å —Å delayed=1 –∏ –ø–æ–ª—É—á–∏—Ç—å req_id"""
        
        async with semaphore:
            params = {
                'user': self.user,
                'key': self.key,
                'query': query,
                'lr': self.lr,
                'groupby': 'attr=d.mode=deep.groups-on-page=20.docs-in-group=1',
                'maxpassages': 2,
                'filter': 'moderate',
                'delayed': '1'
            }
            
            # Retry –ª–æ–≥–∏–∫–∞ –¥–ª—è –æ—à–∏–±–æ–∫ 503 (–ø–µ—Ä–µ–≥—Ä—É–∑–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞) –∏ —Å–µ—Ç–µ–≤—ã—Ö –æ—à–∏–±–æ–∫
            max_retries = 3
            for retry_attempt in range(max_retries):
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –±—ã–ª –ª–∏ –Ω–µ–¥–∞–≤–Ω–æ 503 –æ—Ç –¥—Ä—É–≥–∏—Ö –∑–∞–ø—Ä–æ—Å–æ–≤
                await self._check_and_wait_for_503()
                
                # Rate limiting: —Å–æ–±–ª—é–¥–∞–µ–º –ª–∏–º–∏—Ç –∑–∞–ø—Ä–æ—Å–æ–≤ –≤ —Å–µ–∫—É–Ω–¥—É
                await self._wait_for_rate_limit()
                
                try:
                    # –£–±–µ–∂–¥–∞–µ–º—Å—è —á—Ç–æ —Å–µ—Å—Å–∏—è –∞–∫—Ç–∏–≤–Ω–∞
                    await self._ensure_session()
                    
                    # –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ —Å–µ—Å—Å–∏—è –Ω–µ –±—ã–ª–∞ –∑–∞–∫—Ä—ã—Ç–∞ –º–µ–∂–¥—É –≤—ã–∑–æ–≤–∞–º–∏
                    if self._session is None or self._session.closed:
                        raise aiohttp.ClientConnectionError("Session is closed or None")
                    
                    async with self._session.get(
                        self.url,
                        params=params,
                        timeout=aiohttp.ClientTimeout(total=10)
                    ) as response:
                        # –ü—Ä–æ–≤–µ—Ä—è–µ–º HTTP —Å—Ç–∞—Ç—É—Å –∫–æ–¥
                        if response.status != 200:
                            error_text = await response.text()
                            # –ü—ã—Ç–∞–µ–º—Å—è –∏–∑–≤–ª–µ—á—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ–± –æ—à–∏–±–∫–µ –∏–∑ HTML
                            if response.status == 503:
                                # –û—Ç–º–µ—á–∞–µ–º –≥–ª–æ–±–∞–ª—å–Ω–æ —á—Ç–æ —Å–µ—Ä–≤–µ—Ä –ø–µ—Ä–µ–≥—Ä—É–∂–µ–Ω
                                await self._mark_503_error()
                                
                                # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞ HTML —Å—Ç—Ä–∞–Ω–∏—Ü—É —Å –æ—à–∏–±–∫–æ–π
                                if '<html' in error_text.lower() or '<title>' in error_text.lower():
                                    title_match = re.search(r'<title>([^<]+)</title>', error_text, re.IGNORECASE)
                                    title = title_match.group(1) if title_match else "Service Temporarily Unavailable"
                                    
                                    # –ï—Å–ª–∏ –Ω–µ –ø–æ—Å–ª–µ–¥–Ω—è—è –ø–æ–ø—ã—Ç–∫–∞ - –∂–¥—ë–º 60 —Å–µ–∫ –∏ –ø–æ–≤—Ç–æ—Ä—è–µ–º
                                    if retry_attempt < max_retries - 1:
                                        print(f"   ‚ö†Ô∏è  –°–µ—Ä–≤–µ—Ä –ø–µ—Ä–µ–≥—Ä—É–∂–µ–Ω (503) –¥–ª—è –∑–∞–ø—Ä–æ—Å–∞ '{query[:50]}...'. –û–∂–∏–¥–∞–Ω–∏–µ 60 —Å–µ–∫ –ø–µ—Ä–µ–¥ –ø–æ–≤—Ç–æ—Ä–æ–º...")
                                        await asyncio.sleep(60)
                                        continue  # –ü–æ–≤—Ç–æ—Ä—è–µ–º –ø–æ–ø—ã—Ç–∫—É
                                    
                                    raise Exception(f"HTTP {response.status} {title} (—Å–µ—Ä–≤–µ—Ä –≤—Ä–µ–º–µ–Ω–Ω–æ –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω –ø–æ—Å–ª–µ {max_retries} –ø–æ–ø—ã—Ç–æ–∫)")
                                else:
                                    # 503 –Ω–æ –Ω–µ HTML - —Ç–æ–∂–µ –∂–¥—ë–º
                                    if retry_attempt < max_retries - 1:
                                        print(f"   ‚ö†Ô∏è  –°–µ—Ä–≤–µ—Ä –ø–µ—Ä–µ–≥—Ä—É–∂–µ–Ω (503) –¥–ª—è –∑–∞–ø—Ä–æ—Å–∞ '{query[:50]}...'. –û–∂–∏–¥–∞–Ω–∏–µ 60 —Å–µ–∫ –ø–µ—Ä–µ–¥ –ø–æ–≤—Ç–æ—Ä–æ–º...")
                                        await asyncio.sleep(60)
                                        continue
                                    
                                    raise Exception(f"HTTP {response.status}: {error_text[:200]}")
                            raise Exception(f"HTTP {response.status}: {error_text[:200]}")
                    
                    xml_text = await response.text()
                    
                    # –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ –æ—Ç–≤–µ—Ç –Ω–µ HTML (–º–æ–∂–µ—Ç –±—ã—Ç—å –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞)
                    if xml_text.strip().lower().startswith('<html'):
                        # –ü—ã—Ç–∞–µ–º—Å—è –∏–∑–≤–ª–µ—á—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ–± –æ—à–∏–±–∫–µ –∏–∑ HTML
                        title_match = re.search(r'<title>([^<]+)</title>', xml_text, re.IGNORECASE)
                        title = title_match.group(1) if title_match else "Server Error"
                        h1_match = re.search(r'<h1[^>]*>([^<]+)</h1>', xml_text, re.IGNORECASE)
                        h1 = h1_match.group(1) if h1_match else ""
                        error_msg = f"{title}" + (f": {h1}" if h1 else "")
                        raise Exception(f"–°–µ—Ä–≤–µ—Ä –≤–µ—Ä–Ω—É–ª HTML –≤–º–µ—Å—Ç–æ XML: {error_msg}")
                    
                    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞ –æ—à–∏–±–∫–∏ API
                    if '<error' in xml_text:
                        error_match = re.search(r'<error[^>]*code="([^"]*)"[^>]*>([^<]+)</error>', xml_text)
                        if error_match:
                            error_code = error_match.group(1)
                            error_msg = error_match.group(2)
                            raise Exception(f"API error (code={error_code}): {error_msg}")
                        else:
                            # –ü—ã—Ç–∞–µ–º—Å—è –∏–∑–≤–ª–µ—á—å —Ç–µ–∫—Å—Ç –æ—à–∏–±–∫–∏ –¥—Ä—É–≥–∏–º —Å–ø–æ—Å–æ–±–æ–º
                            error_match = re.search(r'<error[^>]*>([^<]+)</error>', xml_text)
                            error_msg = error_match.group(1) if error_match else xml_text[:200]
                            raise Exception(f"API error: {error_msg}")
                    
                    # –ò–∑–≤–ª–µ–∫–∞–µ–º req_id
                    req_id_match = re.search(r'<req_id>([^<]+)</req_id>', xml_text)
                    if not req_id_match:
                        raise Exception(f"No req_id in response (–≤–æ–∑–º–æ–∂–Ω–æ –æ—à–∏–±–∫–∞ API): {xml_text[:200]}")
                    
                    req_id = req_id_match.group(1)
                    
                    # –°–æ—Ö—Ä–∞–Ω—è–µ–º req_id –≤ –ë–î –°–†–ê–ó–£ –ø–æ—Å–ª–µ –ø–æ–ª—É—á–µ–Ω–∏—è
                    # –ü—Ä–∏ –æ—à–∏–±–∫–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è callback –¥–µ–ª–∞–µ—Ç –ø–∞—É–∑—É –∏ –ø–æ–≤—Ç–æ—Ä—è–µ—Ç –ø–æ–ø—ã—Ç–∫—É
                    # –≠—Ç–æ –¥–∞—ë—Ç –ë–î –≤—Ä–µ–º—è –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–∏—Ç—å—Å—è –ø—Ä–∏ –≤—Ä–µ–º–µ–Ω–Ω—ã—Ö –ø—Ä–æ–±–ª–µ–º–∞—Ö
                    if on_req_id_received:
                        try:
                            on_req_id_received(query, req_id)
                        except Exception as e:
                            # –û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è - –ª–æ–≥–∏—Ä—É–µ–º, –Ω–æ –ø—Ä–æ–¥–æ–ª–∂–∞–µ–º –æ—Ç–ø—Ä–∞–≤–∫—É
                            # Callback —Å–∞–º –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –ø–æ–≤—Ç–æ—Ä–Ω—ã–µ –ø–æ–ø—ã—Ç–∫–∏
                            print(f"   ‚ö†Ô∏è  –û—à–∏–±–∫–∞ –≤ callback —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è req_id –¥–ª—è '{query[:50]}...': {e}")
                    
                    # Progress callback
                    if progress_callback and index % 50 == 0:
                        progress_callback(index, total, query, 'sent')
                    
                    return PendingRequest(
                        query=query,
                        req_id=req_id,
                        sent_at=datetime.now()
                    )
                
                except asyncio.TimeoutError:
                    if retry_attempt < max_retries - 1:
                        await asyncio.sleep(2)  # –ö–æ—Ä–æ—Ç–∫–∞—è –ø–∞—É–∑–∞ –ø–µ—Ä–µ–¥ –ø–æ–≤—Ç–æ—Ä–æ–º
                        continue
                    raise Exception(f"Timeout –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ –∑–∞–ø—Ä–æ—Å–∞ (10 —Å–µ–∫) –ø–æ—Å–ª–µ {max_retries} –ø–æ–ø—ã—Ç–æ–∫")
                except (aiohttp.ClientError, aiohttp.ClientConnectionError, ConnectionResetError, OSError) as e:
                    # –°–µ—Ç–µ–≤—ã–µ –æ—à–∏–±–∫–∏ (Connection closed –∏ —Ç.–¥.) - –ø—Ä–æ–±—É–µ–º –ø–æ–≤—Ç–æ—Ä–∏—Ç—å
                    error_msg = f"{type(e).__name__} - {str(e)}"
                    
                    if retry_attempt < max_retries - 1:
                        wait_time = (retry_attempt + 1) * 2  # 2, 4, 6 —Å–µ–∫
                        
                        # –í–°–ï–ì–î–ê –ø–µ—Ä–µ—Å–æ–∑–¥–∞—ë–º —Å–µ—Å—Å–∏—é –ø—Ä–∏ —Å–µ—Ç–µ–≤—ã—Ö –æ—à–∏–±–∫–∞—Ö
                        try:
                            async with self._session_lock:
                                if self._session:
                                    try:
                                        # –ó–∞–∫—Ä—ã–≤–∞–µ–º connector –ø–µ—Ä–≤—ã–º
                                        if hasattr(self._session, '_connector') and self._session._connector:
                                            if not self._session._connector.closed:
                                                await self._session._connector.close()
                                        # –ó–∞—Ç–µ–º —Å–µ—Å—Å–∏—é
                                        if not self._session.closed:
                                            await self._session.close()
                                        await asyncio.sleep(0.5)  # –£–≤–µ–ª–∏—á–µ–Ω–Ω–æ–µ –≤—Ä–µ–º—è –æ–∂–∏–¥–∞–Ω–∏—è
                                    except:
                                        pass
                                    finally:
                                        self._session = None
                            
                            # –°–æ–∑–¥–∞—ë–º –Ω–æ–≤—É—é —Å–µ—Å—Å–∏—é
                            await self._ensure_session()
                        except Exception as recreate_error:
                            # –ï—Å–ª–∏ –Ω–µ –º–æ–∂–µ–º –ø–µ—Ä–µ—Å–æ–∑–¥–∞—Ç—å —Å–µ—Å—Å–∏—é - –∂–¥—ë–º –¥–æ–ª—å—à–µ
                            wait_time = wait_time * 2
                        
                        await asyncio.sleep(wait_time)
                        continue
                    raise Exception(f"–°–µ—Ç–µ–≤–∞—è –æ—à–∏–±–∫–∞ –ø–æ—Å–ª–µ {max_retries} –ø–æ–ø—ã—Ç–æ–∫: {error_msg}")
                except Exception as e:
                    # –ï—Å–ª–∏ —É–∂–µ –Ω–∞—à–µ –∏—Å–∫–ª—é—á–µ–Ω–∏–µ —Å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–µ–π - –ø—Ä–æ–±—Ä–∞—Å—ã–≤–∞–µ–º –∫–∞–∫ –µ—Å—Ç—å
                    if "API error" in str(e) or "No req_id" in str(e):
                        if retry_attempt < max_retries - 1:
                            await asyncio.sleep(2)
                            continue
                        raise Exception(f"–ó–∞–ø—Ä–æ—Å '{query}': {str(e)}")
                    raise Exception(f"–ó–∞–ø—Ä–æ—Å '{query}': {type(e).__name__} - {str(e)}")
    
    async def _fetch_result_by_req_id(
        self,
        pending: PendingRequest,
        semaphore: asyncio.Semaphore,
        progress_callback: Optional[Callable]
    ) -> Dict[str, Any]:
        """–ü–æ–ª—É—á–∏—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç –ø–æ req_id"""
        
        async with semaphore:
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –±—ã–ª –ª–∏ –Ω–µ–¥–∞–≤–Ω–æ 503 –æ—Ç –¥—Ä—É–≥–∏—Ö –∑–∞–ø—Ä–æ—Å–æ–≤
            await self._check_and_wait_for_503()
            
            # Rate limiting: —Å–æ–±–ª—é–¥–∞–µ–º –ª–∏–º–∏—Ç –∑–∞–ø—Ä–æ—Å–æ–≤ –≤ —Å–µ–∫—É–Ω–¥—É
            await self._wait_for_rate_limit()
            
            # –£–±–µ–∂–¥–∞–µ–º—Å—è —á—Ç–æ —Å–µ—Å—Å–∏—è –∞–∫—Ç–∏–≤–Ω–∞
            await self._ensure_session()
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ —Å–µ—Å—Å–∏—è –Ω–µ –±—ã–ª–∞ –∑–∞–∫—Ä—ã—Ç–∞ –º–µ–∂–¥—É –≤—ã–∑–æ–≤–∞–º–∏
            if self._session is None or self._session.closed:
                raise aiohttp.ClientConnectionError("Session is closed or None")
            
            params = {
                'user': self.user,
                'key': self.key,
                'req_id': pending.req_id
            }
            
            try:
                async with self._session.get(
                    self.url,
                    params=params,
                    timeout=aiohttp.ClientTimeout(total=10)
                ) as response:
                    # –ü—Ä–æ–≤–µ—Ä—è–µ–º HTTP —Å—Ç–∞—Ç—É—Å –∫–æ–¥
                    if response.status != 200:
                        error_text = await response.text()
                        # –ü—ã—Ç–∞–µ–º—Å—è –∏–∑–≤–ª–µ—á—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ–± –æ—à–∏–±–∫–µ –∏–∑ HTML
                        if response.status == 503:
                            # –û—Ç–º–µ—á–∞–µ–º –≥–ª–æ–±–∞–ª—å–Ω–æ —á—Ç–æ —Å–µ—Ä–≤–µ—Ä –ø–µ—Ä–µ–≥—Ä—É–∂–µ–Ω
                            await self._mark_503_error()
                            
                            if '<html' in error_text.lower() or '<title>' in error_text.lower():
                                title_match = re.search(r'<title>([^<]+)</title>', error_text, re.IGNORECASE)
                                title = title_match.group(1) if title_match else "Service Temporarily Unavailable"
                                # –í–æ–∑–≤—Ä–∞—â–∞–µ–º —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã–π —Å—Ç–∞—Ç—É—Å –¥–ª—è retry —Å –∑–∞–¥–µ—Ä–∂–∫–æ–π
                                return {
                                    'query': pending.query,
                                    'req_id': pending.req_id,
                                    'status': 'retry_503',
                                    'error': f"HTTP {response.status} {title} (—Å–µ—Ä–≤–µ—Ä –≤—Ä–µ–º–µ–Ω–Ω–æ –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω)",
                                    'xml_response': error_text
                                }
                            else:
                                # 503 –Ω–æ –Ω–µ HTML - —Ç–æ–∂–µ retry
                                return {
                                    'query': pending.query,
                                    'req_id': pending.req_id,
                                    'status': 'retry_503',
                                    'error': f"HTTP {response.status}: {error_text[:200]}",
                                    'xml_response': error_text
                                }
                        return {
                            'query': pending.query,
                            'req_id': pending.req_id,
                            'status': 'error',
                            'error': f"HTTP {response.status}: {error_text[:200]}",
                            'xml_response': error_text
                        }
                    
                    xml_text = await response.text()
                    
                    # –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ –æ—Ç–≤–µ—Ç –Ω–µ HTML (–º–æ–∂–µ—Ç –±—ã—Ç—å –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞)
                    if xml_text.strip().lower().startswith('<html'):
                        title_match = re.search(r'<title>([^<]+)</title>', xml_text, re.IGNORECASE)
                        title = title_match.group(1) if title_match else "Server Error"
                        h1_match = re.search(r'<h1[^>]*>([^<]+)</h1>', xml_text, re.IGNORECASE)
                        h1 = h1_match.group(1) if h1_match else ""
                        error_msg = f"{title}" + (f": {h1}" if h1 else "")
                        return {
                            'query': pending.query,
                            'req_id': pending.req_id,
                            'status': 'error',
                            'error': f"–°–µ—Ä–≤–µ—Ä –≤–µ—Ä–Ω—É–ª HTML –≤–º–µ—Å—Ç–æ XML: {error_msg}",
                            'xml_response': xml_text
                        }
                    
                    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞ 202 (–µ—â—ë –Ω–µ –≥–æ—Ç–æ–≤–æ)
                    if 'code="202"' in xml_text or '–Ω–µ –æ–±—Ä–∞–±–æ—Ç–∞–Ω' in xml_text:
                        return {
                            'query': pending.query,
                            'req_id': pending.req_id,
                            'status': 'pending',
                            'message': 'Result not ready yet (202)'
                        }
                    
                    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞ –æ—à–∏–±–∫–∏
                    if '<error' in xml_text:
                        error_match = re.search(r'<error[^>]*>([^<]+)</error>', xml_text)
                        error_msg = error_match.group(1) if error_match else xml_text[:200]
                        return {
                            'query': pending.query,
                            'req_id': pending.req_id,
                            'status': 'error',
                            'error': error_msg,
                            'xml_response': xml_text
                        }
                    
                    # –£—Å–ø–µ—à–Ω—ã–π –æ—Ç–≤–µ—Ç
                    return {
                        'query': pending.query,
                        'req_id': pending.req_id,
                        'status': 'completed',
                        'xml_response': xml_text
                    }
            
            except (aiohttp.ClientError, aiohttp.ClientConnectionError, ConnectionResetError, OSError) as e:
                # –°–µ—Ç–µ–≤—ã–µ –æ—à–∏–±–∫–∏ - –ø–µ—Ä–µ—Å–æ–∑–¥–∞—ë–º —Å–µ—Å—Å–∏—é –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º pending –¥–ª—è –ø–æ–≤—Ç–æ—Ä–∞
                try:
                    async with self._session_lock:
                        if self._session:
                            try:
                                # –ó–∞–∫—Ä—ã–≤–∞–µ–º connector –ø–µ—Ä–≤—ã–º
                                if hasattr(self._session, '_connector') and self._session._connector:
                                    if not self._session._connector.closed:
                                        await self._session._connector.close()
                                # –ó–∞—Ç–µ–º —Å–µ—Å—Å–∏—é
                                if not self._session.closed:
                                    await self._session.close()
                                await asyncio.sleep(0.5)
                            except:
                                pass
                            finally:
                                self._session = None
                    
                    # –ü—ã—Ç–∞–µ–º—Å—è –ø–µ—Ä–µ—Å–æ–∑–¥–∞—Ç—å —Å–µ—Å—Å–∏—é
                    await self._ensure_session()
                except Exception:
                    # –ï—Å–ª–∏ –Ω–µ –º–æ–∂–µ–º –ø–µ—Ä–µ—Å–æ–∑–¥–∞—Ç—å - –Ω–µ –∫—Ä–∏—Ç–∏—á–Ω–æ, –ø–æ–ø—Ä–æ–±—É–µ–º –≤ —Å–ª–µ–¥—É—é—â–∏–π —Ä–∞–∑
                    pass
                
                # –í–æ–∑–≤—Ä–∞—â–∞–µ–º pending –¥–ª—è –ø–æ–≤—Ç–æ—Ä–∞ (–≤–º–µ—Å—Ç–æ error)
                return {
                    'query': pending.query,
                    'req_id': pending.req_id,
                    'status': 'pending',
                    'message': f"Connection error (will retry): {type(e).__name__} - {str(e)}"
                }
            except asyncio.TimeoutError:
                # –¢–∞–π–º–∞—É—Ç—ã - —Ç–æ–∂–µ –ø–æ–≤—Ç–æ—Ä—è–µ–º
                return {
                    'query': pending.query,
                    'req_id': pending.req_id,
                    'status': 'pending',
                    'message': 'Request timeout (will retry)'
                }
            except Exception as e:
                return {
                    'query': pending.query,
                    'req_id': pending.req_id,
                    'status': 'error',
                    'error': f"Fetch error: {type(e).__name__} - {str(e)}"
                }


__all__ = ['AsyncBatchSERPClient', 'PendingRequest']

